From d6540a71e46a75986cca30003b48fb9a78917621 Mon Sep 17 00:00:00 2001
From: Johannes Schindelin <johannes.schindelin@gmx.de>
Date: Fri, 30 Nov 2018 11:23:50 +0100
Subject: [PATCH] Avoid nested functions

It was reported to the oss-security mailing list in
https://seclists.org/oss-sec/2018/q4/82 that GCC 7 and 8 have known
issues generating code for nested functions, essentially voiding any
Data Execution Protection (DEP).

As it is unclear how quickly GCC can be fixed, let's just avoid the
nested functions altogether.

Note: this patch mainly moves the nested functions out of their previous
host function, if necessary adds a suffix to the function name, and in
several cases declares structures to be passed via the `lParam` argument
of the `Enum*()` functions, to retain access to the local variables of
the former host function.

Note, too, that trailing whitespace was preserved faithfully when moving
and de-indenting the code.

Also please note that this patch does *not* care about code that is not
compiled because it is hidden behind `#if ... #endif` guards.

Signed-off-by: Johannes Schindelin <johannes.schindelin@gmx.de>
---
 src/config.c   | 142 ++++++++++--------
 src/wininput.c | 166 +++++++++++----------
 src/winmain.c  | 395 +++++++++++++++++++++++++++----------------------
 src/wintext.c  | 168 +++++++++++----------
 4 files changed, 473 insertions(+), 398 deletions(-)

diff --git a/src/config.c b/src/config.c
index 2e92022..0136113 100644
--- a/src/config.c
+++ b/src/config.c
@@ -2469,44 +2469,47 @@ font_size_handler(control *ctrl, int event)
   }
 }
 
-void
-list_fonts(bool report)
-{
-  HDC dc = GetDC(0);
+struct data_fontenum {
+  HDC dc;
+  bool report, initial;
+};
 
-  int CALLBACK fontenum(const ENUMLOGFONTW *lpelf, const NEWTEXTMETRICW *lpntm, DWORD fontType, LPARAM lParam)
-  {
-    const LOGFONTW * lfp = &lpelf->elfLogFont;
-    (void)lpntm, (void)fontType;
+static int CALLBACK
+fontenum(const ENUMLOGFONTW *lpelf, const NEWTEXTMETRICW *lpntm, DWORD fontType, LPARAM lParam)
+{
+  const LOGFONTW * lfp = &lpelf->elfLogFont;
+  struct data_fontenum *data = (struct data_fontenum *)lParam;
+  (void)lpntm, (void)fontType;
 
-    if (lParam) {
-      if ((lfp->lfPitchAndFamily & 3) == FIXED_PITCH && !lfp->lfCharSet)
-        EnumFontFamiliesW(dc, lfp->lfFaceName, (FONTENUMPROCW)fontenum, 0);
-    }
-    else if (!lfp->lfItalic && !lfp->lfCharSet) {
-      if (lfp->lfFaceName[0] == '@')
-        // skip vertical font families
-        return 1;
+  if (data->initial) {
+    data->initial = 0;
+    if ((lfp->lfPitchAndFamily & 3) == FIXED_PITCH && !lfp->lfCharSet)
+      EnumFontFamiliesW(data->dc, lfp->lfFaceName, (FONTENUMPROCW)fontenum, (LPARAM)data);
+  }
+  else if (!lfp->lfItalic && !lfp->lfCharSet) {
+    if (lfp->lfFaceName[0] == '@')
+      // skip vertical font families
+      return 1;
 
-      wchar * tagsplit(wchar * fn, wstring style)
-      {
+    wchar * tagsplit(wchar * fn, wstring style)
+    {
 #if CYGWIN_VERSION_API_MINOR >= 74
-        wchar * tag = wcsstr(fn, style);
-        if (tag) {
-          int n = wcslen(style);
-          if (tag[n] <= ' ' && tag != fn && tag[-1] == ' ') {
-            tag[-1] = 0;
-            tag[n] = 0;
-            return tag;
-          }
+      wchar * tag = wcsstr(fn, style);
+      if (tag) {
+        int n = wcslen(style);
+        if (tag[n] <= ' ' && tag != fn && tag[-1] == ' ') {
+          tag[-1] = 0;
+          tag[n] = 0;
+          return tag;
         }
+      }
 #else
-        (void)fn; (void)style;
+      (void)fn; (void)style;
 #endif
-        return 0;
-      }
+      return 0;
+    }
 
-      /**
+    /**
 	Courier|
 	FreeMono|Medium
 	Inconsolata|Medium
@@ -2517,46 +2520,55 @@ list_fonts(bool report)
 	TIFAX|Alpha
 	HanaMinA|Regular
 	DejaVu Sans Mono|Book
-       */
-      wchar * fn = wcsdup(lfp->lfFaceName);
-      wchar * st = tagsplit(fn, W("Oblique"));
-      if ((st = tagsplit(fn, lpelf->elfStyle))) {
-        //   Source Code Pro ExtraLight|ExtraLight
-        //-> Source Code Pro|ExtraLight
-      }
-      else {
-        wchar * fnst = fn;
+     */
+    wchar * fn = wcsdup(lfp->lfFaceName);
+    wchar * st = tagsplit(fn, W("Oblique"));
+    if ((st = tagsplit(fn, lpelf->elfStyle))) {
+      //   Source Code Pro ExtraLight|ExtraLight
+      //-> Source Code Pro|ExtraLight
+    }
+    else {
+      wchar * fnst = fn;
 #if CYGWIN_VERSION_API_MINOR >= 74
-        int digsi = wcscspn(fn, W("0123456789"));
-        int nodigsi = wcsspn(&fn[digsi], W("0123456789"));
-        if (nodigsi)
-          fnst = &fn[digsi + nodigsi];
+      int digsi = wcscspn(fn, W("0123456789"));
+      int nodigsi = wcsspn(&fn[digsi], W("0123456789"));
+      if (nodigsi)
+        fnst = &fn[digsi + nodigsi];
 #endif
-        for (uint i = 0; i < lengthof(weights); i++)
-          if ((st = tagsplit(fnst, weights[i]))) {
-            //   Iosevka Term Slab Medium Obliqu|Regular
-            //-> Iosevka Term Slab|Medium
-            break;
-          }
-      }
-      if (!st || !*st)
-        st = (wchar *)lpelf->elfStyle;
-      if (!*st)
-        st = W("Regular");
-      st = wcsdup(st);
-      fn = renewn(fn, wcslen(fn) + 1);
-
-      if (report)
-        printf("%03ld %ls|%ls [2m[%ls|%ls][0m\n", (long int)lfp->lfWeight, fn, st, lfp->lfFaceName, lpelf->elfStyle);
-      else
-        enterfontlist(fn, lfp->lfWeight, st);
+      for (uint i = 0; i < lengthof(weights); i++)
+        if ((st = tagsplit(fnst, weights[i]))) {
+          //   Iosevka Term Slab Medium Obliqu|Regular
+          //-> Iosevka Term Slab|Medium
+          break;
+        }
     }
-
-    return 1;
+    if (!st || !*st)
+      st = (wchar *)lpelf->elfStyle;
+    if (!*st)
+      st = W("Regular");
+    st = wcsdup(st);
+    fn = renewn(fn, wcslen(fn) + 1);
+
+    if (data->report)
+      printf("%03ld %ls|%ls [2m[%ls|%ls][0m\n", (long int)lfp->lfWeight, fn, st, lfp->lfFaceName, lpelf->elfStyle);
+    else
+      enterfontlist(fn, lfp->lfWeight, st);
   }
 
-  EnumFontFamiliesW(dc, 0, (FONTENUMPROCW)fontenum, 1);
-  ReleaseDC(0, dc);
+  return 1;
+}
+
+void
+list_fonts(bool report)
+{
+  struct data_fontenum data = {
+    .dc = GetDC(0),
+    .report = report,
+    .initial = true
+  };
+
+  EnumFontFamiliesW(data.dc, 0, (FONTENUMPROCW)fontenum, (LPARAM)&data);
+  ReleaseDC(0, data.dc);
 }
 
 static void
diff --git a/src/wininput.c b/src/wininput.c
index 37f8358..149e58d 100644
--- a/src/wininput.c
+++ b/src/wininput.c
@@ -150,104 +150,116 @@ append_commands(HMENU menu, wstring commands, UINT_PTR idm_cmd, bool add_icons)
   free(cmds);
 }
 
-static void
-add_switcher(HMENU menu, bool vsep, bool hsep, bool use_win_icons)
-{
-  uint bar = vsep ? MF_MENUBARBREAK : 0;
-  if (hsep)
-    AppendMenuW(menu, MF_SEPARATOR, 0, 0);
-  //__ Context menu, session switcher ("virtual tabs")
-  AppendMenuW(menu, MF_DISABLED | bar, 0, _W("Session switcher"));
-  AppendMenuW(menu, MF_SEPARATOR, 0, 0);
-  int tabi = 0;
-  clear_tabs();
+struct data_add_switcher {
+  int tabi, use_win_icons;
+  HMENU menu;
+};
 
-  BOOL CALLBACK wnd_enum_tabs(HWND curr_wnd, LPARAM menu)
-  {
-    WINDOWINFO curr_wnd_info;
-    curr_wnd_info.cbSize = sizeof(WINDOWINFO);
-    GetWindowInfo(curr_wnd, &curr_wnd_info);
-    if (class_atom == curr_wnd_info.atomWindowType) {
-      int len = GetWindowTextLengthW(curr_wnd);
-      wchar title[len + 1];
-      len = GetWindowTextW(curr_wnd, title, len + 1);
-
-      AppendMenuW((HMENU)menu, MF_ENABLED, IDM_GOTAB + tabi, title);
-      MENUITEMINFOW mi;
-      mi.cbSize = sizeof(MENUITEMINFOW);
-      mi.fMask = MIIM_STATE;
-      mi.fState = // (IsIconic(curr_wnd) ? MFS_DISABLED : 0) |
-                  (curr_wnd == wnd ? MFS_DEFAULT : 0);
-        /*
-           MFS_DEFAULT: "A menu can contain only one default menu item, 
-                        which is displayed in bold."
-                        but multiple bold entries seem to work
-           MFS_HILITE: highlight is volatile
-           MFS_CHECKED: conflict with other MIIM_BITMAP usage
-        */
-      //if (has_flashed(curr_wnd))
-      //  mi.fState |= MFS_HILITE;
-
-      mi.fMask |= MIIM_BITMAP;
-      //if (has_flashed(curr_wnd))
-      //  mi.hbmpItem = HBMMENU_POPUP_RESTORE;
-      //else
-      if (IsIconic(curr_wnd))
-        mi.hbmpItem = HBMMENU_POPUP_MINIMIZE;
-      else
-        mi.hbmpItem = HBMMENU_POPUP_MAXIMIZE;
+static BOOL CALLBACK
+wnd_enum_tabs(HWND curr_wnd, LPARAM lParam)
+{
+  struct data_add_switcher *data = (struct data_add_switcher *)lParam;
+  HMENU menu = data->menu;
+  WINDOWINFO curr_wnd_info;
+  curr_wnd_info.cbSize = sizeof(WINDOWINFO);
+  GetWindowInfo(curr_wnd, &curr_wnd_info);
+  if (class_atom == curr_wnd_info.atomWindowType) {
+    int len = GetWindowTextLengthW(curr_wnd);
+    wchar title[len + 1];
+    len = GetWindowTextW(curr_wnd, title, len + 1);
+
+    AppendMenuW((HMENU)menu, MF_ENABLED, IDM_GOTAB + data->tabi, title);
+    MENUITEMINFOW mi;
+    mi.cbSize = sizeof(MENUITEMINFOW);
+    mi.fMask = MIIM_STATE;
+    mi.fState = // (IsIconic(curr_wnd) ? MFS_DISABLED : 0) |
+                (curr_wnd == wnd ? MFS_DEFAULT : 0);
+      /*
+         MFS_DEFAULT: "A menu can contain only one default menu item, 
+                      which is displayed in bold."
+                      but multiple bold entries seem to work
+         MFS_HILITE: highlight is volatile
+         MFS_CHECKED: conflict with other MIIM_BITMAP usage
+      */
+    //if (has_flashed(curr_wnd))
+    //  mi.fState |= MFS_HILITE;
+
+    mi.fMask |= MIIM_BITMAP;
+    //if (has_flashed(curr_wnd))
+    //  mi.hbmpItem = HBMMENU_POPUP_RESTORE;
+    //else
+    if (IsIconic(curr_wnd))
+      mi.hbmpItem = HBMMENU_POPUP_MINIMIZE;
+    else
+      mi.hbmpItem = HBMMENU_POPUP_MAXIMIZE;
 
-      if (use_win_icons && !IsIconic(curr_wnd)) {
+    if (data->use_win_icons && !IsIconic(curr_wnd)) {
 # ifdef show_icon_via_itemdata
 # warning does not work
-        mi.fMask |= MIIM_DATA;
-        mi.hbmpItem = HBMMENU_SYSTEM;
-        mi.dwItemData = (ULONG_PTR)curr_wnd;
+      mi.fMask |= MIIM_DATA;
+      mi.hbmpItem = HBMMENU_SYSTEM;
+      mi.dwItemData = (ULONG_PTR)curr_wnd;
 # endif
-        HICON icon = (HICON)GetClassLongPtr(curr_wnd, GCLP_HICONSM);
-        if (icon) {
-          // convert icon to bitmap
-          //https://stackoverflow.com/questions/7375003/how-to-convert-hicon-to-hbitmap-in-vc/16787105#16787105
+      HICON icon = (HICON)GetClassLongPtr(curr_wnd, GCLP_HICONSM);
+      if (icon) {
+        // convert icon to bitmap
+        //https://stackoverflow.com/questions/7375003/how-to-convert-hicon-to-hbitmap-in-vc/16787105#16787105
 # ifdef it_could_be_simple_Microsoft
-          // simple solution, loses transparency (black border)
-          ICONINFO ii;
-          GetIconInfo(icon, &ii);
-          HBITMAP bitmap = ii.hbmColor;
+        // simple solution, loses transparency (black border)
+        ICONINFO ii;
+        GetIconInfo(icon, &ii);
+        HBITMAP bitmap = ii.hbmColor;
 # else
-          HBITMAP bitmap = icon_bitmap(icon);
+        HBITMAP bitmap = icon_bitmap(icon);
 # endif
 
-          mi.fMask |= MIIM_BITMAP;
-          mi.hbmpItem = bitmap;
-        }
+        mi.fMask |= MIIM_BITMAP;
+        mi.hbmpItem = bitmap;
       }
+    }
 
 #ifdef show_icon_via_callback
 #warning does not work
-      mi.fMask |= MIIM_BITMAP;
-      mi.hbmpItem = HBMMENU_CALLBACK;
+    mi.fMask |= MIIM_BITMAP;
+    mi.hbmpItem = HBMMENU_CALLBACK;
 #endif
 
 #ifdef show_checkmarks
-      // this works only if both hbmpChecked and hbmpUnchecked are populated,
-      // not using HBMMENU_ predefines
-      mi.fMask |= MIIM_CHECKMARKS;
-      mi.fMask &= ~MIIM_BITMAP;
-      mi.hbmpChecked = mi.hbmpItem;  // test value (from use_win_icons)
-      mi.hbmpUnchecked = NULL;
-      if (!IsIconic(curr_wnd))
-        mi.fState |= MFS_CHECKED;
+    // this works only if both hbmpChecked and hbmpUnchecked are populated,
+    // not using HBMMENU_ predefines
+    mi.fMask |= MIIM_CHECKMARKS;
+    mi.fMask &= ~MIIM_BITMAP;
+    mi.hbmpChecked = mi.hbmpItem;  // test value (from data->use_win_icons)
+    mi.hbmpUnchecked = NULL;
+    if (!IsIconic(curr_wnd))
+      mi.fState |= MFS_CHECKED;
 #endif
 
-      SetMenuItemInfoW((HMENU)menu, IDM_GOTAB + tabi, 0, &mi);
-      add_tab(tabi, curr_wnd);
+    SetMenuItemInfoW((HMENU)menu, IDM_GOTAB + data->tabi, 0, &mi);
+    add_tab(data->tabi, curr_wnd);
 
-      tabi++;
-    }
-    return true;
+    data->tabi++;
   }
+  return true;
+}
+
+static void
+add_switcher(HMENU menu, bool vsep, bool hsep, bool use_win_icons)
+{
+  uint bar = vsep ? MF_MENUBARBREAK : 0;
+  if (hsep)
+    AppendMenuW(menu, MF_SEPARATOR, 0, 0);
+  //__ Context menu, session switcher ("virtual tabs")
+  AppendMenuW(menu, MF_DISABLED | bar, 0, _W("Session switcher"));
+  AppendMenuW(menu, MF_SEPARATOR, 0, 0);
+  struct data_add_switcher data = {
+    .tabi = 0,
+    .use_win_icons = use_win_icons,
+    .menu = menu
+  };
+  clear_tabs();
 
-  EnumWindows(wnd_enum_tabs, (LPARAM)menu);
+  EnumWindows(wnd_enum_tabs, (LPARAM)&data);
 }
 
 static bool
diff --git a/src/winmain.c b/src/winmain.c
index 80e2e5c..e237b4a 100644
--- a/src/winmain.c
+++ b/src/winmain.c
@@ -395,86 +395,90 @@ add_tabinfo(unsigned long tag, HWND wnd, wchar * title)
   }
 }
 
+static int
+comp_tabinfo(const void * t1, const void * t2)
+{
+  if (((struct tabinfo *)t1)->tag < ((struct tabinfo *)t2)->tag)
+    return -1;
+  if (((struct tabinfo *)t1)->tag > ((struct tabinfo *)t2)->tag)
+    return 1;
+  else
+    return 0;
+}
+
 static void
 sort_tabinfo()
 {
-  int comp_tabinfo(const void * t1, const void * t2)
-  {
-    if (((struct tabinfo *)t1)->tag < ((struct tabinfo *)t2)->tag)
-      return -1;
-    if (((struct tabinfo *)t1)->tag > ((struct tabinfo *)t2)->tag)
-      return 1;
-    else
-      return 0;
-  }
   qsort(tabinfo, ntabinfo, sizeof(struct tabinfo), comp_tabinfo);
 }
 
-/*
-  Enumerate all windows of the mintty class.
-  ///TODO: Maintain a local list of them.
-  To be used for tab bar display.
- */
-static void
-refresh_tab_titles(bool trace)
+static BOOL CALLBACK
+wnd_enum_tabs_refresh_tab_titles(HWND curr_wnd, LPARAM lp)
 {
-  BOOL CALLBACK wnd_enum_tabs(HWND curr_wnd, LPARAM lp)
-  {
-    (void)lp;
-    WINDOWINFO curr_wnd_info;
-    curr_wnd_info.cbSize = sizeof(WINDOWINFO);
-    GetWindowInfo(curr_wnd, &curr_wnd_info);
-    if (class_atom == curr_wnd_info.atomWindowType) {
-      int len = GetWindowTextLengthW(curr_wnd);
-      if (!len) {
-        // check whether already terminating
-        LONG fini = GetWindowLong(curr_wnd, GWL_USERDATA);
-        if (fini) {
+  bool trace = (bool)lp;
+
+  WINDOWINFO curr_wnd_info;
+  curr_wnd_info.cbSize = sizeof(WINDOWINFO);
+  GetWindowInfo(curr_wnd, &curr_wnd_info);
+  if (class_atom == curr_wnd_info.atomWindowType) {
+    int len = GetWindowTextLengthW(curr_wnd);
+    if (!len) {
+      // check whether already terminating
+      LONG fini = GetWindowLong(curr_wnd, GWL_USERDATA);
+      if (fini) {
 #ifdef debug_tabbar
-          printf("[%8p] get tab %8p: fini\n", wnd, curr_wnd);
+        printf("[%8p] get tab %8p: fini\n", wnd, curr_wnd);
 #endif
-          return true;
-        }
+        return true;
       }
-      wchar title[len + 1];
-      GetWindowTextW(curr_wnd, title, len + 1);
+    }
+    wchar title[len + 1];
+    GetWindowTextW(curr_wnd, title, len + 1);
 #ifdef debug_tabbar
-      printf("[%8p] get tab %8p: <%ls>\n", wnd, curr_wnd, title);
+    printf("[%8p] get tab %8p: <%ls>\n", wnd, curr_wnd, title);
 #endif
 
-      static bool sort_tabs_by_time = true;
-
-      if (sort_tabs_by_time) {
-        DWORD pid;
-        GetWindowThreadProcessId(curr_wnd, &pid);
-        HANDLE ph = OpenProcess(PROCESS_QUERY_INFORMATION, 0, pid);
-        // PROCESS_QUERY_LIMITED_INFORMATION ?
-        FILETIME cr_time, dummy;
-        if (GetProcessTimes(ph, &cr_time, &dummy, &dummy, &dummy)) {
-          unsigned long long crtime = ((unsigned long long)cr_time.dwHighDateTime << 32) | cr_time.dwLowDateTime;
-          add_tabinfo(crtime, curr_wnd, title);
-          if (trace) {
+    static bool sort_tabs_by_time = true;
+
+    if (sort_tabs_by_time) {
+      DWORD pid;
+      GetWindowThreadProcessId(curr_wnd, &pid);
+      HANDLE ph = OpenProcess(PROCESS_QUERY_INFORMATION, 0, pid);
+      // PROCESS_QUERY_LIMITED_INFORMATION ?
+      FILETIME cr_time, dummy;
+      if (GetProcessTimes(ph, &cr_time, &dummy, &dummy, &dummy)) {
+        unsigned long long crtime = ((unsigned long long)cr_time.dwHighDateTime << 32) | cr_time.dwLowDateTime;
+        add_tabinfo(crtime, curr_wnd, title);
+        if (trace) {
 #ifdef debug_tabbar
-            SYSTEMTIME start_time;
-            if (FileTimeToSystemTime(&cr_time, &start_time))
-              printf("  %04d-%02d-%02d_%02d:%02d:%02d.%03d\n",
-                     start_time.wYear, start_time.wMonth, start_time.wDay,
-                     start_time.wHour, start_time.wMinute, 
-                     start_time.wSecond, start_time.wMilliseconds);
+          SYSTEMTIME start_time;
+          if (FileTimeToSystemTime(&cr_time, &start_time))
+            printf("  %04d-%02d-%02d_%02d:%02d:%02d.%03d\n",
+                   start_time.wYear, start_time.wMonth, start_time.wDay,
+                   start_time.wHour, start_time.wMinute, 
+                   start_time.wSecond, start_time.wMilliseconds);
 #endif
-          }
         }
-        CloseHandle(ph);
       }
-      else
-        add_tabinfo((unsigned long)curr_wnd, curr_wnd, title);
-
+      CloseHandle(ph);
     }
-    return true;
+    else
+      add_tabinfo((unsigned long)curr_wnd, curr_wnd, title);
+
   }
+  return true;
+}
 
+/*
+  Enumerate all windows of the mintty class.
+  ///TODO: Maintain a local list of them.
+  To be used for tab bar display.
+ */
+static void
+refresh_tab_titles(bool trace)
+{
   clear_tabinfo();
-  EnumWindows(wnd_enum_tabs, 0);
+  EnumWindows(wnd_enum_tabs_refresh_tab_titles, (LPARAM)trace);
   sort_tabinfo();
 #if defined(debug_tabbar) || defined(debug_win_switch)
   for (int w = 0; w < ntabinfo; w++)
@@ -482,33 +486,35 @@ refresh_tab_titles(bool trace)
 #endif
 }
 
+static BOOL CALLBACK
+wnd_enum_tabs_update_tab_titles(HWND curr_wnd, LPARAM lp)
+{
+  (void)lp;
+  WINDOWINFO curr_wnd_info;
+  curr_wnd_info.cbSize = sizeof(WINDOWINFO);
+  GetWindowInfo(curr_wnd, &curr_wnd_info);
+  if (class_atom == curr_wnd_info.atomWindowType) {
+    if (curr_wnd != wnd) {
+      PostMessage(curr_wnd, WM_USER, 0, WIN_TITLE);
+#ifdef debug_tabbar
+      printf("notified %8p to update tabbar\n", curr_wnd);
+#endif
+    }
+  }
+  return true;
+}
+
 /*
   Update list of windows in all windows of the mintty class.
  */
 static void
 update_tab_titles()
 {
-  BOOL CALLBACK wnd_enum_tabs(HWND curr_wnd, LPARAM lp)
-  {
-    (void)lp;
-    WINDOWINFO curr_wnd_info;
-    curr_wnd_info.cbSize = sizeof(WINDOWINFO);
-    GetWindowInfo(curr_wnd, &curr_wnd_info);
-    if (class_atom == curr_wnd_info.atomWindowType) {
-      if (curr_wnd != wnd) {
-        PostMessage(curr_wnd, WM_USER, 0, WIN_TITLE);
-#ifdef debug_tabbar
-        printf("notified %8p to update tabbar\n", curr_wnd);
-#endif
-      }
-    }
-    return true;
-  }
   if (cfg.geom_sync) {
     // update my own list
     refresh_tab_titles(true);
     // tell the others to update their's
-    EnumWindows(wnd_enum_tabs, 0);
+    EnumWindows(wnd_enum_tabs_update_tab_titles, 0);
   }
 }
 
@@ -838,37 +844,41 @@ win_gotab(uint n)
 #endif
 }
 
-static void
-win_synctabs(int level)
+static BOOL CALLBACK
+wnd_enum_tabs_win_synctabs(HWND curr_wnd, LPARAM lp)
 {
-  BOOL CALLBACK wnd_enum_tabs(HWND curr_wnd, LPARAM lp)
-  {
-    (void)lp;
-    WINDOWINFO curr_wnd_info;
-    curr_wnd_info.cbSize = sizeof(WINDOWINFO);
-    GetWindowInfo(curr_wnd, &curr_wnd_info);
-    if (class_atom == curr_wnd_info.atomWindowType) {
-      if (curr_wnd != wnd) {
-        if (win_is_fullscreen)
-          PostMessage(curr_wnd, WM_USER, 0, WIN_MAXIMIZE);
-        else if (level == 3) // minimize
-          PostMessage(curr_wnd, WM_USER, 0, WIN_MINIMIZE);
-        else {
-          RECT r;
-          GetWindowRect(wnd, &r);
+  int level = (int)lp;
+
+  WINDOWINFO curr_wnd_info;
+  curr_wnd_info.cbSize = sizeof(WINDOWINFO);
+  GetWindowInfo(curr_wnd, &curr_wnd_info);
+  if (class_atom == curr_wnd_info.atomWindowType) {
+    if (curr_wnd != wnd) {
+      if (win_is_fullscreen)
+        PostMessage(curr_wnd, WM_USER, 0, WIN_MAXIMIZE);
+      else if (level == 3) // minimize
+        PostMessage(curr_wnd, WM_USER, 0, WIN_MINIMIZE);
+      else {
+        RECT r;
+        GetWindowRect(wnd, &r);
 #ifdef debug_tabs
-          printf("sync all %d,%d %d,%d\n", (int)r.left, (int)r.top, (int)(r.right - r.left), (int)(r.bottom - r.top));
+        printf("sync all %d,%d %d,%d\n", (int)r.left, (int)r.top, (int)(r.right - r.left), (int)(r.bottom - r.top));
 #endif
-          PostMessage(curr_wnd, WM_USER,
-                      MAKEWPARAM(r.right - r.left, r.bottom - r.top),
-                      MAKELPARAM(r.left, r.top));
-        }
+        PostMessage(curr_wnd, WM_USER,
+                    MAKEWPARAM(r.right - r.left, r.bottom - r.top),
+                    MAKELPARAM(r.left, r.top));
       }
     }
-    return true;
   }
-  if (cfg.geom_sync >= level)
-    EnumWindows(wnd_enum_tabs, 0);
+  return true;
+}
+
+static void
+win_synctabs(int level)
+{
+  if (cfg.geom_sync >= level) {
+    EnumWindows(wnd_enum_tabs_win_synctabs, (LPARAM)level);
+  }
 }
 
 
@@ -894,22 +904,33 @@ get_my_monitor_info(MONITORINFO *mip)
   GetMonitorInfo(mon, mip);
 }
 
-static void
-get_monitor_info(int moni, MONITORINFO *mip)
+
+struct data_get_monitor_info {
+  int moni;
+  MONITORINFO *mip;
+};
+
+static BOOL CALLBACK
+monitor_enum_get_monitor_info(HMONITOR hMonitor, HDC hdcMonitor, LPRECT monp, LPARAM lParam)
 {
-  mip->cbSize = sizeof(MONITORINFO);
+  struct data_get_monitor_info *data = (struct data_get_monitor_info *)lParam;
+  (void)hdcMonitor, (void)monp;
 
-  BOOL CALLBACK
-  monitor_enum(HMONITOR hMonitor, HDC hdcMonitor, LPRECT monp, LPARAM dwData)
-  {
-    (void)hdcMonitor, (void)monp, (void)dwData;
+  GetMonitorInfo(hMonitor, data->mip);
 
-    GetMonitorInfo(hMonitor, mip);
+  return --(data->moni) > 0;
+}
 
-    return --moni > 0;
-  }
+static void
+get_monitor_info(int moni, MONITORINFO *mip)
+{
+  mip->cbSize = sizeof(MONITORINFO);
 
-  EnumDisplayMonitors(0, 0, monitor_enum, 0);
+  struct data_get_monitor_info data = {
+    .moni = moni,
+    .mip = mip
+  };
+  EnumDisplayMonitors(0, 0, monitor_enum_get_monitor_info, (LPARAM)&data);
 }
 
 #define dont_debug_display_monitors_mockup
@@ -933,6 +954,62 @@ static long primary_monitor = 2 - 1;
 static long current_monitor = 1 - 1;  // assumption for MonitorFromWindow
 #endif
 
+struct data_search_monitors {
+  HMONITOR lookup_mon;
+  int moni;
+  int moni_found;
+  int *minx, *miny;
+  RECT vscr;
+  HMONITOR refmon, curmon;
+  int get_primary;
+  bool print_monitors;
+};
+
+static BOOL CALLBACK
+monitor_enum_search_monitors(HMONITOR hMonitor, HDC hdcMonitor, LPRECT monp, LPARAM dwData)
+{
+  struct data_search_monitors *data = (struct data_search_monitors *)dwData;
+  (void)hdcMonitor, (void)monp;
+
+  (data->moni) ++;
+  if (hMonitor == data->lookup_mon) {
+    // looking for index of specific monitor
+    data->moni_found = data->moni;
+    return FALSE;
+  }
+
+  MONITORINFO mi;
+  mi.cbSize = sizeof(MONITORINFO);
+  GetMonitorInfo(hMonitor, &mi);
+
+  if (data->get_primary && (mi.dwFlags & MONITORINFOF_PRIMARY)) {
+    data->moni_found = data->moni;  // fallback to be overridden by monitor found later
+    data->refmon = hMonitor;
+  }
+
+  // determining smallest monitor width and height
+  RECT fr = mi.rcMonitor;
+  if (*(data->minx) == 0 || *(data->minx) > fr.right - fr.left)
+    *(data->minx) = fr.right - fr.left;
+  if (*(data->miny) == 0 || *(data->miny) > fr.bottom - fr.top)
+    *(data->miny) = fr.bottom - fr.top;
+  data->vscr.top = min(data->vscr.top, fr.top);
+  data->vscr.left = min(data->vscr.left, fr.left);
+  data->vscr.right = max(data->vscr.right, fr.right);
+  data->vscr.bottom = max(data->vscr.bottom, fr.bottom);
+
+  if (data->print_monitors) {
+    printf("Monitor %d %s %s width,height %4d,%4d (%4d,%4d...%4d,%4d)\n", 
+           data->moni,
+           hMonitor == data->curmon ? "current" : "       ",
+           mi.dwFlags & MONITORINFOF_PRIMARY ? "primary" : "       ",
+           (int)(fr.right - fr.left), (int)(fr.bottom - fr.top),
+           (int)fr.left, (int)fr.top, (int)fr.right, (int)fr.bottom);
+  }
+
+  return TRUE;
+}
+
 /*
    search_monitors(&x, &y, 0, false, &moninfo)
      returns number of monitors;
@@ -993,86 +1070,48 @@ search_monitors(int * minx, int * miny, HMONITOR lookup_mon, int get_primary, MO
   }
 #endif
 
-  int moni = 0;
-  int moni_found = 0;
+  struct data_search_monitors data = {
+    .moni = 0,
+    .moni_found = 0,
+    .minx = minx,
+    .miny = miny,
+    .vscr = (RECT){0, 0, 0, 0},
+    .refmon = 0,
+    .curmon = lookup_mon ? 0 : MonitorFromWindow(wnd, MONITOR_DEFAULTTONEAREST),
+    .get_primary = get_primary,
+    .print_monitors = !lookup_mon && !mip && get_primary
+  };
+
   * minx = 0;
   * miny = 0;
-  RECT vscr = (RECT){0, 0, 0, 0};
-  HMONITOR refmon = 0;
-  HMONITOR curmon = lookup_mon ? 0 : MonitorFromWindow(wnd, MONITOR_DEFAULTTONEAREST);
-  bool print_monitors = !lookup_mon && !mip && get_primary;
 #ifdef debug_display_monitors
-  print_monitors = !lookup_mon;
+  data.print_monitors = !lookup_mon;
 #endif
 
-  BOOL CALLBACK
-  monitor_enum(HMONITOR hMonitor, HDC hdcMonitor, LPRECT monp, LPARAM dwData)
-  {
-    (void)hdcMonitor, (void)monp, (void)dwData;
-
-    moni ++;
-    if (hMonitor == lookup_mon) {
-      // looking for index of specific monitor
-      moni_found = moni;
-      return FALSE;
-    }
-
-    MONITORINFO mi;
-    mi.cbSize = sizeof(MONITORINFO);
-    GetMonitorInfo(hMonitor, &mi);
-
-    if (get_primary && (mi.dwFlags & MONITORINFOF_PRIMARY)) {
-      moni_found = moni;  // fallback to be overridden by monitor found later
-      refmon = hMonitor;
-    }
-
-    // determining smallest monitor width and height
-    RECT fr = mi.rcMonitor;
-    if (*minx == 0 || *minx > fr.right - fr.left)
-      *minx = fr.right - fr.left;
-    if (*miny == 0 || *miny > fr.bottom - fr.top)
-      *miny = fr.bottom - fr.top;
-    vscr.top = min(vscr.top, fr.top);
-    vscr.left = min(vscr.left, fr.left);
-    vscr.right = max(vscr.right, fr.right);
-    vscr.bottom = max(vscr.bottom, fr.bottom);
-
-    if (print_monitors) {
-      printf("Monitor %d %s %s width,height %4d,%4d (%4d,%4d...%4d,%4d)\n", 
-             moni,
-             hMonitor == curmon ? "current" : "       ",
-             mi.dwFlags & MONITORINFOF_PRIMARY ? "primary" : "       ",
-             (int)(fr.right - fr.left), (int)(fr.bottom - fr.top),
-             (int)fr.left, (int)fr.top, (int)fr.right, (int)fr.bottom);
-    }
-
-    return TRUE;
-  }
-
-  EnumDisplayMonitors(0, 0, monitor_enum, 0);
+  EnumDisplayMonitors(0, 0, monitor_enum_search_monitors, (LPARAM)&data);
 
-  if (!lookup_mon && !mip && !get_primary) {
-    *minx = vscr.right - vscr.left;
-    *miny = vscr.bottom - vscr.top;
-    return moni;
+  if (!data.lookup_mon && !mip && !data.get_primary) {
+    *minx = data.vscr.right - data.vscr.left;
+    *miny = data.vscr.bottom - data.vscr.top;
+    return data.moni;
   }
-  else if (lookup_mon) {
-    return moni_found;
+  else if (data.lookup_mon) {
+    return data.moni_found;
   }
   else if (mip) {
-    if (!refmon)  // not detected primary monitor as requested?
+    if (!data.refmon)  // not detected primary monitor as requested?
       // determine current monitor
-      refmon = MonitorFromWindow(wnd, MONITOR_DEFAULTTONEAREST);
+      data.refmon = MonitorFromWindow(wnd, MONITOR_DEFAULTTONEAREST);
     mip->cbSize = sizeof(MONITORINFO);
-    GetMonitorInfo(refmon, mip);
-    if (get_primary == 2) {
-      *minx = vscr.left;
-      *miny = vscr.top;
+    GetMonitorInfo(data.refmon, mip);
+    if (data.get_primary == 2) {
+      *minx = data.vscr.left;
+      *miny = data.vscr.top;
     }
-    return moni;  // number of monitors
+    return data.moni;  // number of monitors
   }
   else
-    return moni;  // number of monitors printed
+    return data.moni;  // number of monitors printed
 }
 
 
diff --git a/src/wintext.c b/src/wintext.c
index c9b4f13..fe86205 100644
--- a/src/wintext.c
+++ b/src/wintext.c
@@ -328,6 +328,41 @@ get_default_charset(void)
     return DEFAULT_CHARSET;
 }
 
+struct data_adjust_font_weights {
+  struct fontfam *ff;
+  int fw_norm_0, fw_bold_0, fw_norm_1, fw_bold_1, default_charset;
+  bool font_found, ansi_found, cs_found;
+};
+
+static int CALLBACK
+enum_fonts_adjust_font_weights(const LOGFONTW * lfp, const TEXTMETRICW * tmp, DWORD fontType, LPARAM lParam)
+{
+  struct data_adjust_font_weights *data = (struct data_adjust_font_weights *)lParam;
+  (void)tmp;
+  (void)fontType;
+
+#if defined(debug_fonts) && debug_fonts > 1
+  trace_font(("%ls %dx%d %d it %d cs %d %s\n", lfp->lfFaceName, (int)lfp->lfWidth, (int)lfp->lfHeight, (int)lfp->lfWeight, lfp->lfItalic, lfp->lfCharSet, (lfp->lfPitchAndFamily & 3) == FIXED_PITCH ? "fixed" : ""));
+#endif
+
+  data->font_found = true;
+  if (lfp->lfCharSet == ANSI_CHARSET)
+    data->ansi_found = true;
+  if (lfp->lfCharSet == data->default_charset || lfp->lfCharSet == DEFAULT_CHARSET)
+    data->cs_found = true;
+
+  if (lfp->lfWeight > data->fw_norm_0 && lfp->lfWeight <= data->ff->fw_norm)
+    data->fw_norm_0 = lfp->lfWeight;
+  if (lfp->lfWeight > data->fw_bold_0 && lfp->lfWeight <= data->ff->fw_bold)
+    data->fw_bold_0 = lfp->lfWeight;
+  if (lfp->lfWeight < data->fw_norm_1 && lfp->lfWeight >= data->ff->fw_norm)
+    data->fw_norm_1 = lfp->lfWeight;
+  if (lfp->lfWeight < data->fw_bold_1 && lfp->lfWeight >= data->ff->fw_bold)
+    data->fw_bold_1 = lfp->lfWeight;
+
+  return 1;  // continue
+}
+
 static void
 adjust_font_weights(struct fontfam * ff)
 {
@@ -342,77 +377,53 @@ adjust_font_weights(struct fontfam * ff)
   // find the closest available widths such that
   // fw_norm_0 <= ff->fw_norm <= fw_norm_1
   // fw_bold_0 <= ff->fw_bold <= fw_bold_1
-  int fw_norm_0 = 0;
-  int fw_bold_0 = 0;
-  int fw_norm_1 = 1000;
-  int fw_bold_1 = 1001;
-  bool font_found = false;
-  bool ansi_found = false;
   int default_charset = get_default_charset();
-  bool cs_found = default_charset == DEFAULT_CHARSET;
-
-  int CALLBACK enum_fonts(const LOGFONTW * lfp, const TEXTMETRICW * tmp, DWORD fontType, LPARAM lParam)
-  {
-    (void)tmp;
-    (void)fontType;
-    (void)lParam;
-
-#if defined(debug_fonts) && debug_fonts > 1
-    trace_font(("%ls %dx%d %d it %d cs %d %s\n", lfp->lfFaceName, (int)lfp->lfWidth, (int)lfp->lfHeight, (int)lfp->lfWeight, lfp->lfItalic, lfp->lfCharSet, (lfp->lfPitchAndFamily & 3) == FIXED_PITCH ? "fixed" : ""));
-#endif
-
-    font_found = true;
-    if (lfp->lfCharSet == ANSI_CHARSET)
-      ansi_found = true;
-    if (lfp->lfCharSet == default_charset || lfp->lfCharSet == DEFAULT_CHARSET)
-      cs_found = true;
-
-    if (lfp->lfWeight > fw_norm_0 && lfp->lfWeight <= ff->fw_norm)
-      fw_norm_0 = lfp->lfWeight;
-    if (lfp->lfWeight > fw_bold_0 && lfp->lfWeight <= ff->fw_bold)
-      fw_bold_0 = lfp->lfWeight;
-    if (lfp->lfWeight < fw_norm_1 && lfp->lfWeight >= ff->fw_norm)
-      fw_norm_1 = lfp->lfWeight;
-    if (lfp->lfWeight < fw_bold_1 && lfp->lfWeight >= ff->fw_bold)
-      fw_bold_1 = lfp->lfWeight;
-
-    return 1;  // continue
-  }
+  struct data_adjust_font_weights data = {
+    .ff = ff,
+    .fw_norm_0 = 0,
+    .fw_bold_0 = 0,
+    .fw_norm_1 = 1000,
+    .fw_bold_1 = 1001,
+    .default_charset = default_charset,
+    .font_found = false,
+    .ansi_found = false,
+    .cs_found = default_charset == DEFAULT_CHARSET
+  };
 
   HDC dc = GetDC(0);
-  EnumFontFamiliesExW(dc, &lf, enum_fonts, 0, 0);
-  trace_font(("font width (%d)%d(%d)/(%d)%d(%d)", fw_norm_0, ff->fw_norm, fw_norm_1, fw_bold_0, ff->fw_bold, fw_bold_1));
+  EnumFontFamiliesExW(dc, &lf, enum_fonts_adjust_font_weights, (LPARAM)&data, 0);
+  trace_font(("font width (%d)%d(%d)/(%d)%d(%d)", data.fw_norm_0, ff->fw_norm, data.fw_norm_1, data.fw_bold_0, ff->fw_bold, data.fw_bold_1));
   ReleaseDC(0, dc);
 
   // check if no font found
-  if (!font_found) {
+  if (!data.font_found) {
     show_font_warning(ff, _("Font not found, using system substitute"));
     ff->fw_norm = 400;
     ff->fw_bold = 700;
     trace_font(("//\n"));
     return;
   }
-  if (!ansi_found && !cs_found) {
+  if (!data.ansi_found && !data.cs_found) {
     show_font_warning(ff, _("Font has limited support for character ranges"));
   }
 
   // find available widths closest to selected widths
-  if (abs(ff->fw_norm - fw_norm_0) <= abs(ff->fw_norm - fw_norm_1) && fw_norm_0 > 0)
-    ff->fw_norm = fw_norm_0;
-  else if (fw_norm_1 < 1000)
-    ff->fw_norm = fw_norm_1;
-  if (abs(ff->fw_bold - fw_bold_0) < abs(ff->fw_bold - fw_bold_1) || fw_bold_1 > 1000)
-    ff->fw_bold = fw_bold_0;
-  else if (fw_bold_1 < 1001)
-    ff->fw_bold = fw_bold_1;
+  if (abs(ff->fw_norm - data.fw_norm_0) <= abs(ff->fw_norm - data.fw_norm_1) && data.fw_norm_0 > 0)
+    ff->fw_norm = data.fw_norm_0;
+  else if (data.fw_norm_1 < 1000)
+    ff->fw_norm = data.fw_norm_1;
+  if (abs(ff->fw_bold - data.fw_bold_0) < abs(ff->fw_bold - data.fw_bold_1) || data.fw_bold_1 > 1000)
+    ff->fw_bold = data.fw_bold_0;
+  else if (data.fw_bold_1 < 1001)
+    ff->fw_bold = data.fw_bold_1;
   // ensure bold is bolder than normal
   if (ff->fw_bold <= ff->fw_norm) {
     trace_font((" -> %d/%d", ff->fw_norm, ff->fw_bold));
-    if (fw_norm_0 < ff->fw_norm && fw_norm_0 > 0)
-      ff->fw_norm = fw_norm_0;
+    if (data.fw_norm_0 < ff->fw_norm && data.fw_norm_0 > 0)
+      ff->fw_norm = data.fw_norm_0;
     if (ff->fw_bold - ff->fw_norm < 300) {
-      if (fw_bold_1 > ff->fw_bold && fw_bold_1 < 1001)
-        ff->fw_bold = fw_bold_1;
+      if (data.fw_bold_1 > ff->fw_bold && data.fw_bold_1 < 1001)
+        ff->fw_bold = data.fw_bold_1;
       else
         ff->fw_bold = min(ff->fw_norm + 300, 1000);
     }
@@ -731,6 +742,33 @@ wcscasestr(wstring in, wstring find)
   return 0;
 }
 
+static int CALLBACK
+enum_fonts_findFraktur(const LOGFONTW * lfp, const TEXTMETRICW * tmp, DWORD fontType, LPARAM lParam)
+{
+  wstring * fnp = (wstring *)lParam;
+  (void)tmp;
+  (void)fontType;
+
+#if defined(debug_fonts) && debug_fonts > 1
+  trace_font(("%ls %dx%d %d it %d cs %d %s\n", lfp->lfFaceName, (int)lfp->lfWidth, (int)lfp->lfHeight, (int)lfp->lfWeight, lfp->lfItalic, lfp->lfCharSet, (lfp->lfPitchAndFamily & 3) == FIXED_PITCH ? "fixed" : ""));
+#endif
+  if ((lfp->lfPitchAndFamily & 3) == FIXED_PITCH
+   && !lfp->lfCharSet
+   && lfp->lfFaceName[0] != '@'
+     )
+  {
+    if (wcscasestr(lfp->lfFaceName, W("Fraktur"))) {
+      *fnp = wcsdup(lfp->lfFaceName);
+      return 0;  // done
+    }
+    else if (wcscasestr(lfp->lfFaceName, W("Blackletter"))) {
+      *fnp = wcsdup(lfp->lfFaceName);
+      // continue to look for "Fraktur"
+    }
+  }
+  return 1;  // continue
+}
+
 static void
 findFraktur(wstring * fnp)
 {
@@ -739,34 +777,8 @@ findFraktur(wstring * fnp)
   lf.lfPitchAndFamily = 0;
   lf.lfCharSet = ANSI_CHARSET;   // report only ANSI character range
 
-  int CALLBACK enum_fonts(const LOGFONTW * lfp, const TEXTMETRICW * tmp, DWORD fontType, LPARAM lParam)
-  {
-    (void)tmp;
-    (void)fontType;
-    (void)lParam;
-
-#if defined(debug_fonts) && debug_fonts > 1
-    trace_font(("%ls %dx%d %d it %d cs %d %s\n", lfp->lfFaceName, (int)lfp->lfWidth, (int)lfp->lfHeight, (int)lfp->lfWeight, lfp->lfItalic, lfp->lfCharSet, (lfp->lfPitchAndFamily & 3) == FIXED_PITCH ? "fixed" : ""));
-#endif
-    if ((lfp->lfPitchAndFamily & 3) == FIXED_PITCH
-     && !lfp->lfCharSet
-     && lfp->lfFaceName[0] != '@'
-       )
-    {
-      if (wcscasestr(lfp->lfFaceName, W("Fraktur"))) {
-        *fnp = wcsdup(lfp->lfFaceName);
-        return 0;  // done
-      }
-      else if (wcscasestr(lfp->lfFaceName, W("Blackletter"))) {
-        *fnp = wcsdup(lfp->lfFaceName);
-        // continue to look for "Fraktur"
-      }
-    }
-    return 1;  // continue
-  }
-
   HDC dc = GetDC(0);
-  EnumFontFamiliesExW(dc, 0, enum_fonts, 0, 0);
+  EnumFontFamiliesExW(dc, 0, enum_fonts_findFraktur, (LPARAM)fnp, 0);
   ReleaseDC(0, dc);
 }
 
-- 
2.20.0.rc1.windows.1.372.gef51941a303b

