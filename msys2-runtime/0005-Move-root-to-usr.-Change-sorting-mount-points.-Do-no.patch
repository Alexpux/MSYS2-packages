From ea182f0920703fe0e4dff365a34b5f24fa3aa665 Mon Sep 17 00:00:00 2001
From: Alexpux <alexey.pawlow@gmail.com>
Date: Thu, 12 Mar 2015 14:09:29 +0300
Subject: [PATCH 05/23] - Move root to /usr. - Change sorting mount points. -
 Do not show warnings for DOS paths. - By default mount without ACLs. - Can
 read /etc/fstab with short mount point format.

---
 winsup/cygwin/cygheap.cc |   22 +++++-
 winsup/cygwin/globals.cc |    4 +
 winsup/cygwin/mount.cc   |  219 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++-
 winsup/cygwin/mount.h    |    6 +
 winsup/cygwin/uinfo.cc   |    4 +
 5 files changed, 253 insertions(+), 2 deletions(-)

diff --git a/winsup/cygwin/cygheap.cc b/winsup/cygwin/cygheap.cc
index eb60cf279..854aeb953 100644
--- a/winsup/cygwin/cygheap.cc
+++ b/winsup/cygwin/cygheap.cc
@@ -141,7 +141,11 @@ init_cygheap::init_installation_root ()
   ptrdiff_t len = 0;
 
   if (!GetModuleFileNameW (cygwin_hmodule, installation_root_buf, PATH_MAX))
+#ifdef __MSYS__
+    api_fatal ("Can't initialize MSYS2 installation root dir.\n"
+#else
     api_fatal ("Can't initialize Cygwin installation root dir.\n"
+#endif
 	       "GetModuleFileNameW(%p, %p, %u), %E",
 	       cygwin_hmodule, installation_root_buf, PATH_MAX);
   PWCHAR p = installation_root_buf;
@@ -179,15 +183,25 @@ init_cygheap::init_installation_root ()
 
   /* Strip off last path component ("\\cygwin1.dll") */
   PWCHAR w = wcsrchr (installation_root_buf, L'\\');
+#ifdef __MSYS__
+  /* Back two folders to get root as we have all stuff in usr subfolder */
+  for (int i=1; i >=0; --i)
+  {
+#endif
   if (w)
     {
       *w = L'\0';
       w = wcsrchr (installation_root_buf, L'\\');
     }
   if (!w)
+#ifdef __MSYS__
+    api_fatal ("Can't initialize MSYS2 installation root dir.\n"
+	       "Invalid DLL path");
+  }
+#else
     api_fatal ("Can't initialize Cygwin installation root dir.\n"
 	       "Invalid DLL path");
-
+#endif
   /* Copy result into installation_dir before stripping off "bin" dir and
      revert to Win32 path.  This path is added to the Windows environment
      in build_env.  See there for a description. */
@@ -211,6 +225,7 @@ init_cygheap::init_installation_root ()
   RtlInitUnicodeString (&installation_root, installation_root_buf);
   RtlInitUnicodeString (&installation_dir, installation_dir_buf);
 
+#ifndef __MSYS__
   for (int i = 1; i >= 0; --i)
     {
       reg_key r (i, KEY_WRITE, _WIDE (CYGWIN_INFO_INSTALLATIONS_NAME),
@@ -219,6 +234,7 @@ init_cygheap::init_installation_root ()
 				    installation_root_buf)))
 	break;
     }
+#endif
 }
 
 void __stdcall
@@ -298,7 +314,11 @@ _csbrk (int sbs)
 	  MEMORY_BASIC_INFORMATION m;
 	  if (!VirtualQuery (newbase, &m, sizeof m))
 	    system_printf ("couldn't get memory info, %E");
+#ifdef __MSYS__
+	  somekinda_printf ("Couldn't reserve/commit %ld bytes of space for MSYS2's heap, %E",
+#else
 	  somekinda_printf ("Couldn't reserve/commit %ld bytes of space for cygwin's heap, %E",
+#endif
 			    adjsbs);
 	  somekinda_printf ("AllocationBase %p, BaseAddress %p, RegionSize %lx, State %x\n",
 			    m.AllocationBase, m.BaseAddress, m.RegionSize, m.State);
diff --git a/winsup/cygwin/globals.cc b/winsup/cygwin/globals.cc
index ebe8b569f..58af9fa20 100644
--- a/winsup/cygwin/globals.cc
+++ b/winsup/cygwin/globals.cc
@@ -65,7 +65,11 @@ int NO_COPY dynamically_loaded;
 
 /* Some CYGWIN environment variable variables. */
 bool allow_glob = true;
+#ifdef __MSYS__
+bool dos_file_warning = false;
+#else
 bool dos_file_warning;
+#endif
 bool ignore_case_with_glob;
 bool pipe_byte;
 bool reset_com;
diff --git a/winsup/cygwin/mount.cc b/winsup/cygwin/mount.cc
index e0349815d..3fbab18f2 100644
--- a/winsup/cygwin/mount.cc
+++ b/winsup/cygwin/mount.cc
@@ -39,7 +39,9 @@ details. */
   (path_prefix_p (proc, (path), proc_len, false))
 
 bool NO_COPY mount_info::got_usr_bin;
+#ifndef __MSYS__
 bool NO_COPY mount_info::got_usr_lib;
+#endif
 int NO_COPY mount_info::root_idx = -1;
 
 /* is_unc_share: Return non-zero if PATH begins with //server/share
@@ -329,6 +331,18 @@ fs_info::update (PUNICODE_STRING upath, HANDLE in_vol)
 /* These are the minimal flags supported by NTFS since Windows 2000.  Every
    filesystem not supporting these flags is not a native NTFS.  We subsume
    them under the filesystem type "cifs". */
+#ifdef __MSYS__
+#define MINIMAL_WIN_NTFS_FLAGS (FILE_CASE_SENSITIVE_SEARCH \
+				| FILE_CASE_PRESERVED_NAMES \
+				| FILE_UNICODE_ON_DISK \
+				| FILE_FILE_COMPRESSION \
+				| FILE_VOLUME_QUOTAS \
+				| FILE_SUPPORTS_SPARSE_FILES \
+				| FILE_SUPPORTS_REPARSE_POINTS \
+				| FILE_SUPPORTS_OBJECT_IDS \
+				| FILE_SUPPORTS_ENCRYPTION \
+				| FILE_NAMED_STREAMS)
+#else
 #define MINIMAL_WIN_NTFS_FLAGS (FILE_CASE_SENSITIVE_SEARCH \
 				| FILE_CASE_PRESERVED_NAMES \
 				| FILE_UNICODE_ON_DISK \
@@ -340,6 +354,7 @@ fs_info::update (PUNICODE_STRING upath, HANDLE in_vol)
 				| FILE_SUPPORTS_OBJECT_IDS \
 				| FILE_SUPPORTS_ENCRYPTION \
 				| FILE_NAMED_STREAMS)
+#endif
 #define FS_IS_WINDOWS_NTFS TEST_GVI(flags () & MINIMAL_WIN_NTFS_FLAGS, \
 				    MINIMAL_WIN_NTFS_FLAGS)
 /* These are the exact flags of a real Windows FAT/FAT32 filesystem.
@@ -473,13 +488,21 @@ mount_info::create_root_entry (const PWCHAR root)
   sys_wcstombs (native_root, PATH_MAX, root);
   assert (*native_root != '\0');
   if (add_item (native_root, "/",
+#ifdef __MSYS__
+		MOUNT_SYSTEM | MOUNT_IMMUTABLE | MOUNT_AUTOMATIC | MOUNT_NOACL)
+#else
 		MOUNT_SYSTEM | MOUNT_IMMUTABLE | MOUNT_AUTOMATIC)
+#endif
       < 0)
     api_fatal ("add_item (\"%s\", \"/\", ...) failed, errno %d", native_root, errno);
   /* Create a default cygdrive entry.  Note that this is a user entry.
      This allows to override it with mount, unless the sysadmin created
      a cygdrive entry in /etc/fstab. */
+#ifdef __MSYS__
+  cygdrive_flags = MOUNT_NOPOSIX | MOUNT_CYGDRIVE | MOUNT_NOACL;
+#else
   cygdrive_flags = MOUNT_NOPOSIX | MOUNT_CYGDRIVE;
+#endif
   strcpy (cygdrive, CYGWIN_INFO_CYGDRIVE_DEFAULT_PREFIX "/");
   cygdrive_len = strlen (cygdrive);
 }
@@ -499,12 +522,20 @@ mount_info::init (bool user_init)
   pathend = wcpcpy (pathend, L"\\etc\\fstab");
   from_fstab (user_init, path, pathend);
 
-  if (!user_init && (!got_usr_bin || !got_usr_lib))
+#ifdef __MSYS__
+  if (!user_init && !got_usr_bin)
+#else
+  if (!user_init && (!got_usr_bin || !got_usr_lib)
+#endif
     {
       char native[PATH_MAX];
       if (root_idx < 0)
 	api_fatal ("root_idx %d, user_shared magic %y, nmounts %d", root_idx, user_shared->version, nmounts);
       char *p = stpcpy (native, mount[root_idx].native_path);
+#ifdef __MSYS__
+      stpcpy (p, "\\usr\\bin");
+      add_item (native, "/bin", MOUNT_SYSTEM | MOUNT_AUTOMATIC | MOUNT_NOACL);
+#else
       if (!got_usr_bin)
       {
 	stpcpy (p, "\\bin");
@@ -515,6 +546,7 @@ mount_info::init (bool user_init)
 	stpcpy (p, "\\lib");
 	add_item (native, "/usr/lib", MOUNT_SYSTEM | MOUNT_AUTOMATIC);
       }
+#endif
     }
 }
 
@@ -595,6 +627,9 @@ mount_info::conv_to_win32_path (const char *src_path, char *dst, device& dev,
   /* See if this is a cygwin "device" */
   if (win32_device_name (src_path, dst, dev))
     {
+#ifdef __MSYS__
+      debug_printf ("win32_device_name (%s)", src_path);
+#endif
       *flags = 0;
       rc = 0;
       goto out_no_chroot_check;
@@ -625,6 +660,9 @@ mount_info::conv_to_win32_path (const char *src_path, char *dst, device& dev,
     }
   if (isproc (src_path))
     {
+#ifdef __MSYS__
+      debug_printf ("isproc (%s)", src_path);
+#endif
       dev = *proc_dev;
       dev = fhandler_proc::get_proc_fhandler (src_path);
       if (dev == FH_NADA)
@@ -646,7 +684,13 @@ mount_info::conv_to_win32_path (const char *src_path, char *dst, device& dev,
      off the prefix and transform it into an MS-DOS path. */
   else if (iscygdrive (src_path))
     {
+#ifdef __MSYS__
+      debug_printf ("isproc (%s)", src_path);
+#endif
       int n = mount_table->cygdrive_len - 1;
+#ifdef __MSYS__
+      debug_printf ("iscygdrive (%s) mount_table->cygdrive %s", src_path, mount_table->cygdrive);
+#endif
       int unit;
 
       if (!src_path[n])
@@ -657,10 +701,16 @@ mount_info::conv_to_win32_path (const char *src_path, char *dst, device& dev,
 	}
       else if (cygdrive_win32_path (src_path, dst, unit))
 	{
+#ifdef __MSYS__
+          debug_printf ("cygdrive_win32_path (%s)", src_path);
+#endif
 	  *flags = cygdrive_flags;
 	  goto out;
 	}
       else if (mount_table->cygdrive_len > 1)
+#ifdef __MSYS__
+        debug_printf ("mount_table->cygdrive_len > 1 (%s)", src_path);
+#endif
 	return ENOENT;
     }
 
@@ -672,7 +722,12 @@ mount_info::conv_to_win32_path (const char *src_path, char *dst, device& dev,
       const char *path;
       int len;
 
+#ifdef __MSYS__
+      mi = mount + shortest_native_sorted[i];
+      debug_printf (" mount[%d] .. checking %s -> %s ", i, mi->posix_path, mi->native_path);
+#else
       mi = mount + posix_sorted[i];
+#endif
       if (!cygheap->root.exists ()
 	  || (mi->posix_pathlen == 1 && mi->posix_path[0] == '/'))
 	{
@@ -903,7 +958,12 @@ mount_info::conv_to_posix_path (const char *src_path, char *posix_path,
   int pathbuflen = tail - pathbuf;
   for (int i = 0; i < nmounts; ++i)
     {
+#ifdef __MSYS__
+      mount_item &mi = mount[longest_posix_sorted[i]];
+      debug_printf (" mount[%d] .. checking %s -> %s ", i, mi.posix_path, mi.native_path);
+#else
       mount_item &mi = mount[native_sorted[i]];
+#endif
       if (!path_prefix_p (mi.native_path, pathbuf, mi.native_pathlen,
 			  mi.flags & MOUNT_NOPOSIX))
 	continue;
@@ -1116,8 +1176,22 @@ mount_info::from_fstab_line (char *line, bool user)
   if (!*c)
     return true;
   cend = find_ws (c);
+  #ifndef __MSYS__
   *cend = '\0';
+  #endif
   posix_path = conv_fstab_spaces (c);
+  #ifdef __MSYS__
+  if (!*cend)
+   {
+     unsigned mount_flags = MOUNT_SYSTEM | MOUNT_NOPOSIX | MOUNT_NOACL;
+
+     int res = mount_table->add_item (native_path, posix_path, mount_flags);
+     if (res && get_errno () == EMFILE)
+       return false;
+     return true;
+   }
+  *cend = '\0';
+#endif
   /* Third field: FS type. */
   c = skip_ws (cend + 1);
   if (!*c)
@@ -1346,16 +1420,154 @@ sort_by_native_name (const void *a, const void *b)
   return res;
 }
 
+#ifdef __MSYS__
+/* sort_by_longest_posix_name: qsort callback to sort the mount entries.
+   Sort user mounts ahead of system mounts to the same POSIX path. */
+/* FIXME: should the user should be able to choose whether to
+   prefer user or system mounts??? */
+static int
+sort_by_longest_posix_name (const void *a, const void *b)
+{
+  mount_item *ap = mounts_for_sort + (*((int*) a));
+  mount_item *bp = mounts_for_sort + (*((int*) b));
+
+  /* Base weighting on the conversion that would give the longest
+     posix path. */
+  ssize_t alen = (ssize_t) strlen (ap->posix_path) - (ssize_t) strlen (ap->native_path);
+  ssize_t blen = (ssize_t) strlen (bp->posix_path) - (ssize_t) strlen (bp->native_path);
+
+  int res = blen - alen;
+
+  if (res)
+    return res;		/* Path lengths differed */
+
+  /* The two paths were the same length, so just determine normal
+     lexical sorted order. */
+  res = strcmp (ap->posix_path, bp->posix_path);
+
+  if (res == 0)
+   {
+     /* need to select between user and system mount to same POSIX path */
+     if (!(bp->flags & MOUNT_SYSTEM))	/* user mount */
+      return 1;
+     else
+      return -1;
+   }
+
+  return res;
+}
+
+/* sort_by_shortest_native_name: qsort callback to sort the mount entries.
+   Sort user mounts ahead of system mounts to the same POSIX path. */
+/* FIXME: should the user should be able to choose whether to
+   prefer user or system mounts??? */
+static int
+sort_by_shortest_native_name (const void *a, const void *b)
+{
+  mount_item *ap = mounts_for_sort + (*((int*) a));
+  mount_item *bp = mounts_for_sort + (*((int*) b));
+
+  /* Base weighting on the conversion that would give the shortest
+     native path. */
+  ssize_t alen = (ssize_t) strlen (ap->native_path);
+  ssize_t blen = (ssize_t) strlen (bp->native_path);
+
+  int res = alen - blen;
+
+  if (res)
+    return res;		/* Path lengths differed */
+
+  /* The two paths were the same length, so just determine normal
+     lexical sorted order. */
+  res = strcmp (ap->native_path, bp->native_path);
+
+  if (res == 0)
+   {
+     /* need to select between user and system mount to same POSIX path */
+     if (!(bp->flags & MOUNT_SYSTEM))	/* user mount */
+      return 1;
+     else
+      return -1;
+   }
+
+  return res;
+}
+
+static int
+sort_posix_subdirs_before_parents (const void *a, const void *b)
+{
+    mount_item *ap = mounts_for_sort + (*((int*) a));
+    mount_item *bp = mounts_for_sort + (*((int*) b));
+
+    if (ap->posix_pathlen > bp->posix_pathlen)
+    {
+        if (!memcmp (bp->posix_path, ap->posix_path, bp->posix_pathlen))
+        {
+            // bp is a subdir of ap (bp must be moved in-front)
+            return -1;
+        }
+    }
+    else if (ap->posix_pathlen < bp->posix_pathlen)
+    {
+        if (!memcmp (ap->posix_path, bp->posix_path, ap->posix_pathlen))
+        {
+            // ap is a subdir of bp (good as we are)
+            return 1;
+        }
+    }
+    return 0;
+}
+
+#define DISABLE_NEW_STUFF 0
+#define ONLY_USE_NEW_STUFF 1
+
+#endif
+
 void
 mount_info::sort ()
 {
   for (int i = 0; i < nmounts; i++)
+#ifdef __MSYS__
+    native_sorted[i] = posix_sorted[i] = shortest_native_sorted[i] = longest_posix_sorted[i] = i;
+#else
     native_sorted[i] = posix_sorted[i] = i;
+#endif
   /* Sort them into reverse length order, otherwise we won't
      be able to look for /foo in /.  */
   mounts_for_sort = mount;	/* ouch. */
   qsort (posix_sorted, nmounts, sizeof (posix_sorted[0]), sort_by_posix_name);
   qsort (native_sorted, nmounts, sizeof (native_sorted[0]), sort_by_native_name);
+#ifdef __MSYS__
+  qsort (longest_posix_sorted, nmounts, sizeof (longest_posix_sorted[0]), sort_by_longest_posix_name);
+  qsort (shortest_native_sorted, nmounts, sizeof (shortest_native_sorted[0]), sort_by_shortest_native_name);
+  qsort (shortest_native_sorted, nmounts, sizeof (shortest_native_sorted[0]), sort_posix_subdirs_before_parents);
+  /* Disabling my new crap. */
+  #if DISABLE_NEW_STUFF
+  for (int i = 0; i < nmounts; i++)
+  {
+      longest_posix_sorted[i] = native_sorted[i];
+      shortest_native_sorted[i] = posix_sorted[i];
+  }
+  #else
+  #if ONLY_USE_NEW_STUFF
+  for (int i = 0; i < nmounts; i++)
+  {
+      native_sorted[i] = longest_posix_sorted[i];
+      posix_sorted[i] = shortest_native_sorted[i];
+  }
+  #endif
+  #endif
+  for (int i = 0; i < nmounts; i++)
+  {
+      mount_item *mi = mount + shortest_native_sorted[i];
+      debug_printf ("shortest_native_sorted (subdirs before parents)[%d] %12s       %12s", i, mi->native_path, mi->posix_path);
+  }
+  for (int i = 0; i < nmounts; i++)
+  {
+      mount_item *mi = mount + longest_posix_sorted[i];
+      debug_printf ("longest_posix_sorted[%d] %12s       %12s", i, mi->native_path, mi->posix_path);
+  }
+#endif
 }
 
 /* Add an entry to the mount table.
@@ -1446,11 +1658,16 @@ mount_info::add_item (const char *native, const char *posix,
   if (i == nmounts)
     nmounts++;
 
+#ifdef __MSYS__
+  if (strcmp (posixtmp, "/bin") == 0)
+     got_usr_bin = true;
+#else
   if (strcmp (posixtmp, "/usr/bin") == 0)
     got_usr_bin = true;
 
   if (strcmp (posixtmp, "/usr/lib") == 0)
     got_usr_lib = true;
+#endif
 
   if (posixtmp[0] == '/' && posixtmp[1] == '\0' && !(mountflags & MOUNT_CYGDRIVE))
     root_idx = i;
diff --git a/winsup/cygwin/mount.h b/winsup/cygwin/mount.h
index 122a679a8..16a5c8796 100644
--- a/winsup/cygwin/mount.h
+++ b/winsup/cygwin/mount.h
@@ -171,7 +171,9 @@ class mount_info
   mount_item mount[MAX_MOUNTS];
 
   static bool got_usr_bin;
+#ifndef __MSYS__
   static bool got_usr_lib;
+#endif
   static int root_idx;
 
   /* cygdrive_prefix is used as the root of the path automatically
@@ -183,6 +185,10 @@ class mount_info
  private:
   int posix_sorted[MAX_MOUNTS];
   int native_sorted[MAX_MOUNTS];
+#ifdef __MSYS__
+  int longest_posix_sorted[MAX_MOUNTS];
+  int shortest_native_sorted[MAX_MOUNTS];
+#endif
 
  public:
   void init (bool);
diff --git a/winsup/cygwin/uinfo.cc b/winsup/cygwin/uinfo.cc
index bfcce00da..89b435650 100644
--- a/winsup/cygwin/uinfo.cc
+++ b/winsup/cygwin/uinfo.cc
@@ -2791,7 +2791,11 @@ pwdgrp::fetch_account_from_windows (fetch_user_arg_t &arg, cyg_ldap *pldap)
 		     dom, name,
 		     sid.string ((char *) sidstr),
 		     home ?: "/home/", home ? L"" : name,
+#ifdef __MSYS__
+		     shell ?: "/usr/bin/bash");
+#else
 		     shell ?: "/bin/bash");
+#endif
   if (gecos)
     free (gecos);
   if (home)
